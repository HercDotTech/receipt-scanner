#!/bin/bash

PROMPT='given the text below is a receipt, format it as CSV with the following columns: merchant name which is likely to be a single word, receipt date in dd/mm/yyyy HH:mm format, summary of what was purchased, total of the receipt. Respond with a single line representing the CSV data'
BG_COLOR='#b98e6e'

# region Functions
  process_scan() {
    # Get path to current file
    local scan_full_path
    scan_full_path="$1" # Full path: /usr/file/receipt.jpg

    # Trim 20px border from image
    echo "Trimming ..."
    magick "$scan_full_path" -shave 20x20 "$scan_full_path" > /dev/null 2>&1

    # Replace background color to red
    echo "Adjusting background color..."
    magick "$scan_full_path" -fuzz 20% -transparent "$BG_COLOR" -background '#000000' -flatten "$scan_full_path" > /dev/null 2>&1

    # Split input file
    echo "Splitting image..."
    multicrop -c 20,20 -f 40 -u 3 -t 10 -d 200 "$scan_full_path" "$OUTPUT_DIRECTORY"/tmp/split.jpg > /dev/null 2>&1
    rm "$OUTPUT_DIRECTORY"/tmp/scan.jpg

    # Process split
    echo "Processing splits..."
    local splitIndex=1
    local fileName
    local csvContent

    for filePath in "$OUTPUT_DIRECTORY"/tmp/*.jpg; do
      if [ -f "$filePath" ]; then
        echo "Processing split #$splitIndex..."

        # Extract text
        echo "Extracting text..."
        fileName=$(basename "$filePath" .jpg)
        tesseract "$filePath" "$OUTPUT_DIRECTORY"/tmp/"$fileName" -l eng > /dev/null 2>&1

        # Prepend prompt to file
        echo "Adding prompt to file..."
        echo "" | cat - "$OUTPUT_DIRECTORY"/tmp/"$fileName".txt > temp && mv temp "$OUTPUT_DIRECTORY"/tmp/"$fileName".txt
        echo "" | cat - "$OUTPUT_DIRECTORY"/tmp/"$fileName".txt > temp && mv temp "$OUTPUT_DIRECTORY"/tmp/"$fileName".txt
        echo "$PROMPT" | cat - "$OUTPUT_DIRECTORY"/tmp/"$fileName".txt > temp && mv temp "$OUTPUT_DIRECTORY"/tmp/"$fileName".txt

        # Parse text and get CSV
        echo "Running AI magick..."
        csvContent=$(cat "$OUTPUT_DIRECTORY"/tmp/"$fileName".txt | fabric --pattern export_data_as_csv | tail -n1)

        echo "Saving CSV line..."
        echo "$csvContent" >> "$OUTPUT_DIRECTORY"/data.csv

        # Rename image
        echo "Saving receipt image..."
        IFS=',' read -ra csvData <<< "$csvContent"
        local imageName
        local merchant
        local date
        merchant=${csvData[0]// /-}

        date=${csvData[1]// /_}
        date=${date//\//-}
        date=${date//:/-}

        imageName=${merchant}_${date}.jpg
        imageName=${imageName//\"/}
        cp "$filePath" "$OUTPUT_DIRECTORY"/images/"$imageName"

        # Continue
        splitIndex=$((splitIndex + 1))
      fi
    done

    echo "Cleaning up..."
    rm -rf "$OUTPUT_DIRECTORY"/tmp/*
  }

  pause_execution() {
  # Set the input variable to an empty string initially
  local input=""

  # The '-r' flag prevents backslash interpretation
  # The '-p' flag allows us to specify a prompt
  read -r -p "Press [Enter] to scan a new document, or 's' to end scanning: " input

  # Check the input provided by the user.
  # If the user presses ENTER only, 'input' will be empty, and we continue the loop.

  if [[ "$input" =~ ^[sS]$ ]]; then
  # If input is 's' or 'S', return 1 (indicating a stop condition)
  return 1
  else
  # Otherwise (Enter or any other key), return 0 (indicating continue)
  return 0
  fi
  }
# endregion

# region MainScript
  # Check if the correct number of parameters were provided
  if [ "$#" -ne 1 ]; then
  echo "Usage: $0 <OUTPUT_DIRECTORY>" >&2
  exit 1
  fi

  # Assign the command-line parameters to variables
  OUTPUT_DIRECTORY=$(realpath -q "$1")

  # Create directory if not exist
  if [ ! -d "$OUTPUT_DIRECTORY" ]; then
  mkdir -p "$OUTPUT_DIRECTORY"
  fi
  if [ ! -d "$OUTPUT_DIRECTORY"/tmp ]; then
  mkdir -p "$OUTPUT_DIRECTORY"/tmp
  fi
  if [ ! -d "$OUTPUT_DIRECTORY"/images ]; then
  mkdir -p "$OUTPUT_DIRECTORY"/images
  fi

  # Create CSV file if not exists
  if [ ! -f "$OUTPUT_DIRECTORY"/data.csv ]; then
  echo "merchant,date,summary,total" >> "$OUTPUT_DIRECTORY"/data.csv
  fi

  while pause_execution; do
  echo "Connecting to scanner..."
  # Capture images from scanner
  scanline \
  -a4 \
  -resolution 300 \
  -flatbed \
  -jpeg \
  -dir "$OUTPUT_DIRECTORY"/tmp \
  -name "scan"

  echo "Processing scan..."
  if [ -f "$OUTPUT_DIRECTORY"/tmp/scan.jpg ]; then
  process_scan "$OUTPUT_DIRECTORY"/tmp/scan.jpg
  fi
  done;

  echo "Cleaning up..."
  rm -rf "$OUTPUT_DIRECTORY"/tmp
# endregion
